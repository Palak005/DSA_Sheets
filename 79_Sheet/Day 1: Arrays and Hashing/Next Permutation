import java.util.*;

/*************************************************************
 * ðŸ”„ Problem: Next Permutation (LeetCode)
 *
 * Rearranges numbers into the lexicographically next greater permutation.
 * If no such permutation exists, rearranges it as the lowest possible order (ascending).
 *
 * âœ… Optimal Approach:
 *   1. Find the **breakpoint**: index `i` such that nums[i] < nums[i+1] from the end
 *   2. If not found: array is in descending order â†’ reverse entire array
 *   3. Else:
 *      - Find the **smallest number greater than nums[breakpoint]** from the end
 *      - Swap with nums[breakpoint]
 *      - Reverse the subarray from breakpoint+1 to end
 *************************************************************/

class Solution {
    
    // ðŸ” Utility: Reverse elements from index 'start' to 'end'
    public void reverse(int[] nums, int start, int end){
        while(start < end){
            int temp = nums[start];
            nums[start++] = nums[end];
            nums[end--] = temp;
        }
    }

    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int breakPoint = -1;

        // ðŸ” Step 1: Find the break point
        for(int i = n - 2; i >= 0; i--){
            if(nums[i] < nums[i + 1]){
                breakPoint = i;
                break;
            }
        }

        // âš ï¸ If no breakPoint found, array is in descending order
        if(breakPoint == -1){
            reverse(nums, 0, n - 1);
            return;
        }

        // ðŸ” Step 2: Find the next greater element from end
        for(int i = n - 1; i > breakPoint; i--){
            if(nums[i] > nums[breakPoint]){
                int temp = nums[i];
                nums[i] = nums[breakPoint];
                nums[breakPoint] = temp;
                break; // âœ… Important: break after first valid swap
            }
        }

        // ðŸ”„ Step 3: Reverse the suffix
        reverse(nums, breakPoint + 1, n - 1);
    }
}


/*************************************************************
 * ðŸ§  Time Complexity:
 *   - O(n): One pass to find breakpoint + one pass to find swap + reverse
 *
 * ðŸ’¾ Space Complexity:
 *   - O(1): In-place operation
 *************************************************************/


/*************************************************************
 * ðŸ¢ Brute Force Approach (for reference)
 *
 * class Solution {
 *     public void nextPermutation(int[] nums) {
 *         int n = nums.length;
 *         for (int i = n - 2; i >= 0; i--) {
 *             for (int j = n - 1; j > i; j--) {
 *                 if (nums[j] > nums[i]) {
 *                     int temp = nums[i];
 *                     nums[i] = nums[j];
 *                     nums[j] = temp;
 *                     Arrays.sort(nums, i + 1, n); // Sort the suffix
 *                     return;
 *                 }
 *             }
 *         }
 *         Arrays.sort(nums); // Already in descending order
 *     }
 * }
 *************************************************************/
